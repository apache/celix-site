<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Celix: libs/framework/include/celix_bundle_context.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { init_search(); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Celix
   &#160;<span id="projectnumber">2.2.0</span>
   </div>
   <div id="projectbrief">An implementation of the OSGi specification adapted to C and C++</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="dir_6719ab1f1f7655efc2fa43f7eb574fd1.html">libs</a></li><li class="navelem"><a class="el" href="dir_edbb2ffdc3e165978e68de3a46f2e8a0.html">framework</a></li><li class="navelem"><a class="el" href="dir_bc286dd6b945a73064974dfd7e40f558.html">include</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">celix_bundle_context.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;celix_types.h&quot;</code><br />
<code>#include &quot;celix_service_factory.h&quot;</code><br />
<code>#include &quot;celix_properties.h&quot;</code><br />
<code>#include &quot;celix_array_list.h&quot;</code><br />
<code>#include &quot;celix_filter.h&quot;</code><br />
</div><div class="textblock"><div class="dynheader">
Include dependency graph for celix_bundle_context.h:</div>
<div class="dyncontent">
<div class="center"><img src="celix__bundle__context_8h__incl.png" border="0" usemap="#libs_2framework_2include_2celix__bundle__context_8h" alt=""/></div>
<map name="libs_2framework_2include_2celix__bundle__context_8h" id="libs_2framework_2include_2celix__bundle__context_8h">
</map>
</div>
</div><div class="textblock"><div class="dynheader">
This graph shows which files directly or indirectly include this file:</div>
<div class="dyncontent">
<div class="center"><img src="celix__bundle__context_8h__dep__incl.png" border="0" usemap="#libs_2framework_2include_2celix__bundle__context_8hdep" alt=""/></div>
<map name="libs_2framework_2include_2celix__bundle__context_8hdep" id="libs_2framework_2include_2celix__bundle__context_8hdep">
<area shape="rect" id="node2" href="celix__api_8h.html" title="libs/framework/include\l/celix_api.h" alt="" coords="9,184,172,225"/>
<area shape="rect" id="node3" href="celix__bundle__activator_8h.html" title="libs/framework/include\l/celix_bundle_activator.h" alt="" coords="65,95,244,136"/>
</map>
</div>
</div>
<p><a href="celix__bundle__context_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcelix__service__registration__options.html">celix_service_registration_options</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcelix__service__filter__options.html">celix_service_filter_options</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcelix__service__tracking__options.html">celix_service_tracking_options</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcelix__service__use__options.html">celix_service_use_options</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcelix__bundle__tracker__options.html">celix_bundle_tracker_options</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structcelix__service__tracker__info.html">celix_service_tracker_info</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a8ebbfbe80221fe8adc8c3afbdceb570f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a8ebbfbe80221fe8adc8c3afbdceb570f">OPTS_INIT</a></td></tr>
<tr class="separator:a8ebbfbe80221fe8adc8c3afbdceb570f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6020a7ba8712efd0847fdf28e74eb69c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a6020a7ba8712efd0847fdf28e74eb69c">CELIX_EMPTY_SERVICE_REGISTRATION_OPTIONS</a></td></tr>
<tr class="separator:a6020a7ba8712efd0847fdf28e74eb69c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7199f710ea1c193d361e8c151a92bc6a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a7199f710ea1c193d361e8c151a92bc6a">CELIX_EMPTY_SERVICE_FILTER_OPTIONS</a>&#160;&#160;&#160;{.serviceName = NULL, .versionRange = NULL, .filter = NULL, .serviceLanguage = NULL, .ignoreServiceLanguage = false}</td></tr>
<tr class="separator:a7199f710ea1c193d361e8c151a92bc6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae86a28f8d19f6c1e2951172335e0e909"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#ae86a28f8d19f6c1e2951172335e0e909">CELIX_EMPTY_SERVICE_TRACKING_OPTIONS</a></td></tr>
<tr class="separator:ae86a28f8d19f6c1e2951172335e0e909"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6024cf4864950551fa9df01806a69865"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a6024cf4864950551fa9df01806a69865">CELIX_EMPTY_SERVICE_USE_OPTIONS</a></td></tr>
<tr class="separator:a6024cf4864950551fa9df01806a69865"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c68ea824e7268d26852785ea92c777c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a3c68ea824e7268d26852785ea92c777c">CELIX_EMPTY_BUNDLE_TRACKING_OPTIONS</a>&#160;&#160;&#160;{.callbackHandle = NULL, .onStarted = NULL, .onStopped = NULL, .onBundleEvent = NULL}</td></tr>
<tr class="separator:a3c68ea824e7268d26852785ea92c777c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a6bcc1ddc92a68053a0300553baa2e35a"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structcelix__service__registration__options.html">celix_service_registration_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a6bcc1ddc92a68053a0300553baa2e35a">celix_service_registration_options_t</a></td></tr>
<tr class="separator:a6bcc1ddc92a68053a0300553baa2e35a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e95a32f444f0124896a4d193e3be22"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structcelix__service__filter__options.html">celix_service_filter_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a54e95a32f444f0124896a4d193e3be22">celix_service_filter_options_t</a></td></tr>
<tr class="separator:a54e95a32f444f0124896a4d193e3be22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e53ca7fd5a9c2b792ff0a8e048236d2"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structcelix__service__tracking__options.html">celix_service_tracking_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a4e53ca7fd5a9c2b792ff0a8e048236d2">celix_service_tracking_options_t</a></td></tr>
<tr class="separator:a4e53ca7fd5a9c2b792ff0a8e048236d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc6f11edf20a71cbade3668e4bc66ed6"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structcelix__service__use__options.html">celix_service_use_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#abc6f11edf20a71cbade3668e4bc66ed6">celix_service_use_options_t</a></td></tr>
<tr class="separator:abc6f11edf20a71cbade3668e4bc66ed6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6fb701de56577ab43263b5619604e86"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structcelix__bundle__tracker__options.html">celix_bundle_tracker_options</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#ae6fb701de56577ab43263b5619604e86">celix_bundle_tracking_options_t</a></td></tr>
<tr class="separator:ae6fb701de56577ab43263b5619604e86"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a69f5283bcb563038d1a8e35e2a2b028b"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structcelix__service__tracker__info.html">celix_service_tracker_info</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a69f5283bcb563038d1a8e35e2a2b028b">celix_service_tracker_info_t</a></td></tr>
<tr class="separator:a69f5283bcb563038d1a8e35e2a2b028b"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5bc54fd14871cc88ed887c8cea8f7b78"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a5bc54fd14871cc88ed887c8cea8f7b78">celix_bundleContext_registerService</a> (celix_bundle_context_t *ctx, void *svc, const char *serviceName, celix_properties_t *properties)</td></tr>
<tr class="separator:a5bc54fd14871cc88ed887c8cea8f7b78"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3caa917285feaad580b61d4c0c8430a9"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a3caa917285feaad580b61d4c0c8430a9">celix_bundleContext_registerServiceFactory</a> (celix_bundle_context_t *ctx, celix_service_factory_t *factory, const char *serviceName, celix_properties_t *props)</td></tr>
<tr class="separator:a3caa917285feaad580b61d4c0c8430a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abcde0edf5b4969bdd67831cff3db0a43"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#abcde0edf5b4969bdd67831cff3db0a43">celix_bundleContext_registerServiceWithOptions</a> (celix_bundle_context_t *ctx, const <a class="el" href="celix__bundle__context_8h.html#a6bcc1ddc92a68053a0300553baa2e35a">celix_service_registration_options_t</a> *opts)</td></tr>
<tr class="separator:abcde0edf5b4969bdd67831cff3db0a43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ebd82cb3d61aab769956d856293b9b9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a1ebd82cb3d61aab769956d856293b9b9">celix_bundleContext_unregisterService</a> (celix_bundle_context_t *ctx, long serviceId)</td></tr>
<tr class="separator:a1ebd82cb3d61aab769956d856293b9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8322b5aa4adf9dcd8c288ce72a05414"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#ac8322b5aa4adf9dcd8c288ce72a05414">celix_bundleContext_findService</a> (celix_bundle_context_t *ctx, const char *serviceName)</td></tr>
<tr class="separator:ac8322b5aa4adf9dcd8c288ce72a05414"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a96a901f0597f9d2accf073153d90344c"><td class="memItemLeft" align="right" valign="top">celix_array_list_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a96a901f0597f9d2accf073153d90344c">celix_bundleContext_findServices</a> (celix_bundle_context_t *ctx, const char *serviceName)</td></tr>
<tr class="separator:a96a901f0597f9d2accf073153d90344c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cfbbb7e17cb4a825a525c547f72b4b0"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a8cfbbb7e17cb4a825a525c547f72b4b0">celix_bundleContext_findServiceWithOptions</a> (celix_bundle_context_t *ctx, const <a class="el" href="celix__bundle__context_8h.html#a54e95a32f444f0124896a4d193e3be22">celix_service_filter_options_t</a> *opts)</td></tr>
<tr class="separator:a8cfbbb7e17cb4a825a525c547f72b4b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41c34f8165addcbd0d65b4a0c23345d0"><td class="memItemLeft" align="right" valign="top">celix_array_list_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a41c34f8165addcbd0d65b4a0c23345d0">celix_bundleContext_findServicesWithOptions</a> (celix_bundle_context_t *ctx, const <a class="el" href="celix__bundle__context_8h.html#a54e95a32f444f0124896a4d193e3be22">celix_service_filter_options_t</a> *opts)</td></tr>
<tr class="separator:a41c34f8165addcbd0d65b4a0c23345d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a612409acf5453dbc370d93b784153d51"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a612409acf5453dbc370d93b784153d51">celix_bundleContext_trackService</a> (celix_bundle_context_t *ctx, const char *serviceName, void *callbackHandle, void(*set)(void *handle, void *svc))</td></tr>
<tr class="separator:a612409acf5453dbc370d93b784153d51"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43e3bfd38ef956ffe861065e698a72e4"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a43e3bfd38ef956ffe861065e698a72e4">celix_bundleContext_trackServices</a> (celix_bundle_context_t *ctx, const char *serviceName, void *callbackHandle, void(*add)(void *handle, void *svc), void(*remove)(void *handle, void *svc))</td></tr>
<tr class="separator:a43e3bfd38ef956ffe861065e698a72e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a27980e1631d4575cc45c6c6ba38c6f71"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a27980e1631d4575cc45c6c6ba38c6f71">celix_bundleContext_trackServicesWithOptions</a> (celix_bundle_context_t *ctx, const <a class="el" href="celix__bundle__context_8h.html#a4e53ca7fd5a9c2b792ff0a8e048236d2">celix_service_tracking_options_t</a> *opts)</td></tr>
<tr class="separator:a27980e1631d4575cc45c6c6ba38c6f71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b4906a9e6fb34fe3ca5118539a81fc7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a3b4906a9e6fb34fe3ca5118539a81fc7">celix_bundleContext_stopTracker</a> (celix_bundle_context_t *ctx, long trackerId)</td></tr>
<tr class="separator:a3b4906a9e6fb34fe3ca5118539a81fc7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec6e03faece0f8247de19d8c1527406d"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#aec6e03faece0f8247de19d8c1527406d">celix_bundleContext_useServiceWithId</a> (celix_bundle_context_t *ctx, long serviceId, const char *serviceName, void *callbackHandle, void(*use)(void *handle, void *svc))</td></tr>
<tr class="separator:aec6e03faece0f8247de19d8c1527406d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36cdb8a06bb34f9371d7bb32953c69e"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#ac36cdb8a06bb34f9371d7bb32953c69e">celix_bundleContext_useService</a> (celix_bundle_context_t *ctx, const char *serviceName, void *callbackHandle, void(*use)(void *handle, void *svc))</td></tr>
<tr class="separator:ac36cdb8a06bb34f9371d7bb32953c69e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39270507a3766afbfcc9420c7270d262"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a39270507a3766afbfcc9420c7270d262">celix_bundleContext_useServices</a> (celix_bundle_context_t *ctx, const char *serviceName, void *callbackHandle, void(*use)(void *handle, void *svc))</td></tr>
<tr class="separator:a39270507a3766afbfcc9420c7270d262"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e8a78de5f799d303231385b51085055"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a1e8a78de5f799d303231385b51085055">celix_bundleContext_useServiceWithOptions</a> (celix_bundle_context_t *ctx, const <a class="el" href="celix__bundle__context_8h.html#abc6f11edf20a71cbade3668e4bc66ed6">celix_service_use_options_t</a> *opts)</td></tr>
<tr class="separator:a1e8a78de5f799d303231385b51085055"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad1512520baedecad54a7bc307e0a6c7b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#ad1512520baedecad54a7bc307e0a6c7b">celix_bundleContext_useServicesWithOptions</a> (celix_bundle_context_t *ctx, const <a class="el" href="celix__bundle__context_8h.html#abc6f11edf20a71cbade3668e4bc66ed6">celix_service_use_options_t</a> *opts)</td></tr>
<tr class="separator:ad1512520baedecad54a7bc307e0a6c7b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afde9ed40231b5c3bbba19559e68e77f6"><td class="memItemLeft" align="right" valign="top">celix_array_list_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#afde9ed40231b5c3bbba19559e68e77f6">celix_bundleContext_listBundles</a> (celix_bundle_context_t *ctx)</td></tr>
<tr class="separator:afde9ed40231b5c3bbba19559e68e77f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac7151f08ded1d7571867a44abe9f3531"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#ac7151f08ded1d7571867a44abe9f3531">celix_bundleContext_isBundleInstalled</a> (celix_bundle_context_t *ctx, long bndId)</td></tr>
<tr class="separator:ac7151f08ded1d7571867a44abe9f3531"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a727ee2600c19ce2fd42b3b80b695c7f6"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a727ee2600c19ce2fd42b3b80b695c7f6">celix_bundleContext_installBundle</a> (celix_bundle_context_t *ctx, const char *bundleLoc, bool autoStart)</td></tr>
<tr class="separator:a727ee2600c19ce2fd42b3b80b695c7f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a098adf1e9f65deb166110008bd4314dd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a098adf1e9f65deb166110008bd4314dd">celix_bundleContext_uninstallBundle</a> (celix_bundle_context_t *ctx, long bundleId)</td></tr>
<tr class="separator:a098adf1e9f65deb166110008bd4314dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6e1553f9507d04c7a0ad91d067d479b"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#ad6e1553f9507d04c7a0ad91d067d479b">celix_bundleContext_stopBundle</a> (celix_bundle_context_t *ctx, long bundleId)</td></tr>
<tr class="separator:ad6e1553f9507d04c7a0ad91d067d479b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df4bfbc27c99736c0209ef130cff98f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a8df4bfbc27c99736c0209ef130cff98f">celix_bundleContext_startBundle</a> (celix_bundle_context_t *ctx, long bundleId)</td></tr>
<tr class="separator:a8df4bfbc27c99736c0209ef130cff98f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3daf88ae43bb01e104f506c3a2dc8351"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a3daf88ae43bb01e104f506c3a2dc8351">celix_bundleContext_trackBundles</a> (celix_bundle_context_t *ctx, void *callbackHandle, void(*onStarted)(void *handle, const celix_bundle_t *bundle), void(*onStopped)(void *handle, const celix_bundle_t *bundle))</td></tr>
<tr class="separator:a3daf88ae43bb01e104f506c3a2dc8351"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa603acb136351b4135ce6a8c0b1fda71"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#aa603acb136351b4135ce6a8c0b1fda71">celix_bundleContext_trackBundlesWithOptions</a> (celix_bundle_context_t *ctx, const <a class="el" href="celix__bundle__context_8h.html#ae6fb701de56577ab43263b5619604e86">celix_bundle_tracking_options_t</a> *opts)</td></tr>
<tr class="separator:aa603acb136351b4135ce6a8c0b1fda71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb3cedf5ffa7a326cef2af64a1094635"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#abb3cedf5ffa7a326cef2af64a1094635">celix_bundleContext_useBundle</a> (celix_bundle_context_t *ctx, long bundleId, void *callbackHandle, void(*use)(void *handle, const celix_bundle_t *bundle))</td></tr>
<tr class="separator:abb3cedf5ffa7a326cef2af64a1094635"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03a6d1c49c91c212ad7be115e1035840"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a03a6d1c49c91c212ad7be115e1035840">celix_bundleContext_useBundles</a> (celix_bundle_context_t *ctx, void *callbackHandle, void(*use)(void *handle, const celix_bundle_t *bundle))</td></tr>
<tr class="separator:a03a6d1c49c91c212ad7be115e1035840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80f61dd38b9da8447cd4f931779eaf16"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a80f61dd38b9da8447cd4f931779eaf16">celix_bundleContext_trackServiceTrackers</a> (celix_bundle_context_t *ctx, const char *serviceName, void *callbackHandle, void(*trackerAdd)(void *handle, const <a class="el" href="celix__bundle__context_8h.html#a69f5283bcb563038d1a8e35e2a2b028b">celix_service_tracker_info_t</a> *info), void(*trackerRemove)(void *handle, const <a class="el" href="celix__bundle__context_8h.html#a69f5283bcb563038d1a8e35e2a2b028b">celix_service_tracker_info_t</a> *info))</td></tr>
<tr class="separator:a80f61dd38b9da8447cd4f931779eaf16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac36566dcc477bb2c123e5124527090c1"><td class="memItemLeft" align="right" valign="top">celix_dependency_manager_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#ac36566dcc477bb2c123e5124527090c1">celix_bundleContext_getDependencyManager</a> (celix_bundle_context_t *ctx)</td></tr>
<tr class="separator:ac36566dcc477bb2c123e5124527090c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7f55d1587f421f27518574a525ff63"><td class="memItemLeft" align="right" valign="top">celix_bundle_t *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a3f7f55d1587f421f27518574a525ff63">celix_bundleContext_getBundle</a> (celix_bundle_context_t *ctx)</td></tr>
<tr class="separator:a3f7f55d1587f421f27518574a525ff63"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa121100c5f5d03c0ccdda9c87286f7db"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#aa121100c5f5d03c0ccdda9c87286f7db">celix_bundleContext_getProperty</a> (celix_bundle_context_t *ctx, const char *key, const char *defaultVal)</td></tr>
<tr class="separator:aa121100c5f5d03c0ccdda9c87286f7db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ea27b2a81018583a464a10932cfae62"><td class="memItemLeft" align="right" valign="top">long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a0ea27b2a81018583a464a10932cfae62">celix_bundleContext_getPropertyAsLong</a> (celix_bundle_context_t *ctx, const char *key, long defaultValue)</td></tr>
<tr class="separator:a0ea27b2a81018583a464a10932cfae62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92be7dd7985a890c4b92bcb8497e8b9f"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a92be7dd7985a890c4b92bcb8497e8b9f">celix_bundleContext_getPropertyAsDouble</a> (celix_bundle_context_t *ctx, const char *key, double defaultValue)</td></tr>
<tr class="separator:a92be7dd7985a890c4b92bcb8497e8b9f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a41e6642ba1a739b5768911fa41e5d170"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="celix__bundle__context_8h.html#a41e6642ba1a739b5768911fa41e5d170">celix_bundleContext_getPropertyAsBool</a> (celix_bundle_context_t *ctx, const char *key, bool defaultValue)</td></tr>
<tr class="separator:a41e6642ba1a739b5768911fa41e5d170"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a3c68ea824e7268d26852785ea92c777c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CELIX_EMPTY_BUNDLE_TRACKING_OPTIONS&#160;&#160;&#160;{.callbackHandle = NULL, .onStarted = NULL, .onStopped = NULL, .onBundleEvent = NULL}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>C Macro to create a empty celix_service_filter_options_t type. </p>

</div>
</div>
<a class="anchor" id="a7199f710ea1c193d361e8c151a92bc6a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CELIX_EMPTY_SERVICE_FILTER_OPTIONS&#160;&#160;&#160;{.serviceName = NULL, .versionRange = NULL, .filter = NULL, .serviceLanguage = NULL, .ignoreServiceLanguage = false}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>C Macro to create a empty celix_service_filter_options_t type. </p>

</div>
</div>
<a class="anchor" id="a6020a7ba8712efd0847fdf28e74eb69c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CELIX_EMPTY_SERVICE_REGISTRATION_OPTIONS</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ .svc = NULL, \</div><div class="line">    .factory = NULL, \</div><div class="line">    .serviceName = NULL, \</div><div class="line">    .properties = NULL, \</div><div class="line">    .serviceLanguage = NULL, \</div><div class="line">    .serviceVersion = NULL }</div></div><!-- fragment --><p>C Macro to create a empty celix_service_registration_options_t type. </p>

</div>
</div>
<a class="anchor" id="ae86a28f8d19f6c1e2951172335e0e909"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CELIX_EMPTY_SERVICE_TRACKING_OPTIONS</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ .filter.serviceName = NULL, \</div><div class="line">    .filter.versionRange = NULL, \</div><div class="line">    .filter.filter = NULL, \</div><div class="line">    .filter.serviceLanguage = NULL, \</div><div class="line">    .filter.ignoreServiceLanguage = <span class="keyword">false</span>, \</div><div class="line">    .callbackHandle = NULL, \</div><div class="line">    .set = NULL, \</div><div class="line">    .add = NULL, \</div><div class="line">    .remove = NULL, \</div><div class="line">    .setWithProperties = NULL, \</div><div class="line">    .addWithProperties = NULL, \</div><div class="line">    .removeWithProperties = NULL, \</div><div class="line">    .setWithOwner = NULL, \</div><div class="line">    .addWithOwner = NULL, \</div><div class="line">    .removeWithOwner = NULL}</div></div><!-- fragment --><p>C Macro to create a empty celix_service_tracking_options_t type. </p>

</div>
</div>
<a class="anchor" id="a6024cf4864950551fa9df01806a69865"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CELIX_EMPTY_SERVICE_USE_OPTIONS</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{.filter.serviceName = NULL, \</div><div class="line">    .filter.versionRange = NULL, \</div><div class="line">    .filter.filter = NULL, \</div><div class="line">    .filter.serviceLanguage = NULL, \</div><div class="line">    .waitTimeoutInSeconds = 0.0F, \</div><div class="line">    .callbackHandle = NULL, \</div><div class="line">    .use = NULL, \</div><div class="line">    .useWithProperties = NULL, \</div><div class="line">    .useWithOwner = NULL}</div></div><!-- fragment --><p>C Macro to create a empty celix_service_use_options_t type. </p>

</div>
</div>
<a class="anchor" id="a8ebbfbe80221fe8adc8c3afbdceb570f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define OPTS_INIT</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Init macro so that the opts are correctly initialized for C++ compilers </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ae6fb701de56577ab43263b5619604e86"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structcelix__bundle__tracker__options.html">celix_bundle_tracker_options</a>  <a class="el" href="celix__bundle__context_8h.html#ae6fb701de56577ab43263b5619604e86">celix_bundle_tracking_options_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The Service Bundle Tracking options can be used to fine tune the requested bundle tracker options. </p>

</div>
</div>
<a class="anchor" id="a54e95a32f444f0124896a4d193e3be22"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structcelix__service__filter__options.html">celix_service_filter_options</a>  <a class="el" href="celix__bundle__context_8h.html#a54e95a32f444f0124896a4d193e3be22">celix_service_filter_options_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Service filter options which can be used to query for certain services. </p>

</div>
</div>
<a class="anchor" id="a6bcc1ddc92a68053a0300553baa2e35a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structcelix__service__registration__options.html">celix_service_registration_options</a>  <a class="el" href="celix__bundle__context_8h.html#a6bcc1ddc92a68053a0300553baa2e35a">celix_service_registration_options_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Service Registration Options when registering services to the Celix framework. </p>

</div>
</div>
<a class="anchor" id="a69f5283bcb563038d1a8e35e2a2b028b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structcelix__service__tracker__info.html">celix_service_tracker_info</a>  <a class="el" href="celix__bundle__context_8h.html#a69f5283bcb563038d1a8e35e2a2b028b">celix_service_tracker_info_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Service Tracker Info provided to the service tracker tracker callbacks. </p>

</div>
</div>
<a class="anchor" id="a4e53ca7fd5a9c2b792ff0a8e048236d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structcelix__service__tracking__options.html">celix_service_tracking_options</a>  <a class="el" href="celix__bundle__context_8h.html#a4e53ca7fd5a9c2b792ff0a8e048236d2">celix_service_tracking_options_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Service Tracker Options used to fine tune which services to track and the callback to be used for the tracked services. </p>

</div>
</div>
<a class="anchor" id="abc6f11edf20a71cbade3668e4bc66ed6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structcelix__service__use__options.html">celix_service_use_options</a>  <a class="el" href="celix__bundle__context_8h.html#abc6f11edf20a71cbade3668e4bc66ed6">celix_service_use_options_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Service Use Options used to fine tune which services to use and which callbacks to use. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ac8322b5aa4adf9dcd8c288ce72a05414"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long celix_bundleContext_findService </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>serviceName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the highest ranking service and returns the service id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The bundle context </td></tr>
    <tr><td class="paramname">serviceName</td><td>The required service name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If found a valid service id (&gt;= 0) if not found -1. </dd></dl>

</div>
</div>
<a class="anchor" id="a96a901f0597f9d2accf073153d90344c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">celix_array_list_t* celix_bundleContext_findServices </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>serviceName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the services with the provided service name and returns a list of the found service ids.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The bundle context </td></tr>
    <tr><td class="paramname">serviceName</td><td>The required service name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A array list with as value a long int. </dd></dl>

</div>
</div>
<a class="anchor" id="a41c34f8165addcbd0d65b4a0c23345d0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">celix_array_list_t* celix_bundleContext_findServicesWithOptions </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="celix__bundle__context_8h.html#a54e95a32f444f0124896a4d193e3be22">celix_service_filter_options_t</a> *&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the services conform the provider filter options and returns a list of the found service ids.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The bundle context </td></tr>
    <tr><td class="paramname">opts</td><td>The pointer to the filter options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A array list with as value a long int. </dd></dl>

</div>
</div>
<a class="anchor" id="a8cfbbb7e17cb4a825a525c547f72b4b0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long celix_bundleContext_findServiceWithOptions </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="celix__bundle__context_8h.html#a54e95a32f444f0124896a4d193e3be22">celix_service_filter_options_t</a> *&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds the highest ranking service and returns the service id.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The bundle context </td></tr>
    <tr><td class="paramname">opts</td><td>The pointer to the filter options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>If found a valid service id (&gt;= 0) if not found -1. </dd></dl>

</div>
</div>
<a class="anchor" id="a3f7f55d1587f421f27518574a525ff63"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">celix_bundle_t* celix_bundleContext_getBundle </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the bundle for this bundle context. </p>

</div>
</div>
<a class="anchor" id="ac36566dcc477bb2c123e5124527090c1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">celix_dependency_manager_t* celix_bundleContext_getDependencyManager </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the dependency manager for this bundle context.</p>
<dl class="section return"><dt>Returns</dt><dd>the dependency manager or NULL if unsuccessful. </dd></dl>

</div>
</div>
<a class="anchor" id="aa121100c5f5d03c0ccdda9c87286f7db"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* celix_bundleContext_getProperty </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>defaultVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the config property - or environment variable if the config property does not exist - for the provided name. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the property to receive. </td></tr>
    <tr><td class="paramname">defaultVal</td><td>The default value to use if the property is not found (can be NULL). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The property value for the provided key or the provided defaultValue is the key is not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a41e6642ba1a739b5768911fa41e5d170"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool celix_bundleContext_getPropertyAsBool </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the config property as converts it to bool. If the property is not a valid bool, the defaultValue will be returned. The rest of the behaviour is the same as celix_bundleContext_getProperty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the property to receive. </td></tr>
    <tr><td class="paramname">defaultVal</td><td>The default value to use if the property is not found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The property value for the provided key or the provided defaultValue is the key is not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a92be7dd7985a890c4b92bcb8497e8b9f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double celix_bundleContext_getPropertyAsDouble </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the config property as converts it to double. If the property is not a valid double, the defaultValue will be returned. The rest of the behaviour is the same as celix_bundleContext_getProperty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the property to receive. </td></tr>
    <tr><td class="paramname">defaultVal</td><td>The default value to use if the property is not found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The property value for the provided key or the provided defaultValue is the key is not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a0ea27b2a81018583a464a10932cfae62"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long celix_bundleContext_getPropertyAsLong </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>defaultValue</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Gets the config property as converts it to long. If the property is not a valid long, the defaultValue will be returned. The rest of the behaviour is the same as celix_bundleContext_getProperty.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">key</td><td>The key of the property to receive. </td></tr>
    <tr><td class="paramname">defaultVal</td><td>The default value to use if the property is not found. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The property value for the provided key or the provided defaultValue is the key is not found. </dd></dl>

</div>
</div>
<a class="anchor" id="a727ee2600c19ce2fd42b3b80b695c7f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long celix_bundleContext_installBundle </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>bundleLoc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>autoStart</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Install and optional start a bundle. Will silently ignore bundle ids &lt; 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The bundle context </td></tr>
    <tr><td class="paramname">bundleLoc</td><td>The bundle location to the bundle zip file. </td></tr>
    <tr><td class="paramname">autoStart</td><td>If the bundle should also be started. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the bundleId (&gt;= 0) or &lt; 0 if the bundle could not be installed and possibly started. </dd></dl>

</div>
</div>
<a class="anchor" id="ac7151f08ded1d7571867a44abe9f3531"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool celix_bundleContext_isBundleInstalled </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>bndId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if whether a bundle is installed. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The bundle context. </td></tr>
    <tr><td class="paramname">bndId</td><td>The bundle id to check </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the bundle is installed. </dd></dl>

</div>
</div>
<a class="anchor" id="afde9ed40231b5c3bbba19559e68e77f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">celix_array_list_t* celix_bundleContext_listBundles </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>List the installed and started bundle ids. The bundle ids does not include the framework bundle (bundle id 0).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The bundle context </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A array with bundle ids (long). The caller is responsible for destroying the array. </dd></dl>

</div>
</div>
<a class="anchor" id="a5bc54fd14871cc88ed887c8cea8f7b78"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long celix_bundleContext_registerService </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>svc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>serviceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">celix_properties_t *&#160;</td>
          <td class="paramname"><em>properties</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a service to the Celix framework.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The bundle context </td></tr>
    <tr><td class="paramname">svc</td><td>the service object. Normally a pointer to a service struct (i.e. a struct with function pointers) </td></tr>
    <tr><td class="paramname">serviceName</td><td>the service name, cannot be NULL </td></tr>
    <tr><td class="paramname">properties</td><td>The meta properties associated with the service. The service registration will take ownership of the properties (i.e. no destroy needed) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The serviceId (&gt;= 0) or &lt; 0 if the registration was unsuccessful. </dd></dl>

</div>
</div>
<a class="anchor" id="a3caa917285feaad580b61d4c0c8430a9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long celix_bundleContext_registerServiceFactory </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">celix_service_factory_t *&#160;</td>
          <td class="paramname"><em>factory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>serviceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">celix_properties_t *&#160;</td>
          <td class="paramname"><em>props</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a service factory in the framework (for the C language). The service factory will be called for every bundle requesting/de-requesting a service. This gives the provider the option to create bundle specific service instances.</p>
<p>When a service is requested for a bundle the getService of the factory service will be called. This function must return a valid pointer to a service conform the registered service name or NULL. When a service in no longer needed for a bundle (e.g. ending the useService(s) calls or when a service tracker is stopped) the ungetService function of the service factory will be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The bundle context </td></tr>
    <tr><td class="paramname">factory</td><td>The pointer to the factory service. </td></tr>
    <tr><td class="paramname">serviceName</td><td>The required service name of the services this factory will produce. </td></tr>
    <tr><td class="paramname">properties</td><td>The optional service factory properties. For a service consumer this will be seen as the service properties. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The serviceId (&gt;= 0) or &lt; 0 if the registration was unsuccessful. </dd></dl>

</div>
</div>
<a class="anchor" id="abcde0edf5b4969bdd67831cff3db0a43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long celix_bundleContext_registerServiceWithOptions </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="celix__bundle__context_8h.html#a6bcc1ddc92a68053a0300553baa2e35a">celix_service_registration_options_t</a> *&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Register a service to the Celix framework using the provided service registration options.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The bundle context </td></tr>
    <tr><td class="paramname">opts</td><td>The pointer to the registration options. The options are only in the during registration call. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The serviceId (&gt;= 0) or &lt; 0 if the registration was unsuccessful. </dd></dl>

</div>
</div>
<a class="anchor" id="a8df4bfbc27c99736c0209ef130cff98f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool celix_bundleContext_startBundle </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>bundleId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Start the bundle with the provided bundle id. Will silently ignore bundle ids &lt; 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The bundle context </td></tr>
    <tr><td class="paramname">bundleId</td><td>The bundle id to start. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the bundle is found &amp; correctly started. False if not. </dd></dl>

</div>
</div>
<a class="anchor" id="ad6e1553f9507d04c7a0ad91d067d479b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool celix_bundleContext_stopBundle </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>bundleId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop the bundle with the provided bundle id. Will silently ignore bundle ids &lt; 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The bundle context </td></tr>
    <tr><td class="paramname">bundleId</td><td>The bundle id to stop. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the bundle is found &amp; correctly stop. False if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a3b4906a9e6fb34fe3ca5118539a81fc7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void celix_bundleContext_stopTracker </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>trackerId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop the tracker with the provided track id. Could be a service tracker, bundle tracker or service tracker tracker. Only works for the trackers owned by the bundle of the bundle context.</p>
<p>Will log a error if the provided tracker id is unknown. Will silently ignore trackerId &lt; 0. </p>

</div>
</div>
<a class="anchor" id="a3daf88ae43bb01e104f506c3a2dc8351"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long celix_bundleContext_trackBundles </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *handle, const celix_bundle_t *bundle)&#160;</td>
          <td class="paramname"><em>onStarted</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *handle, const celix_bundle_t *bundle)&#160;</td>
          <td class="paramname"><em>onStopped</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>track bundles The add bundle callback will also be called for already installed bundles.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The bundle context. </td></tr>
    <tr><td class="paramname">callbackHandle</td><td>The data pointer, which will be used in the callbacks </td></tr>
    <tr><td class="paramname">add</td><td>The callback which will be called for started bundles. </td></tr>
    <tr><td class="paramname">remove</td><td>The callback which will be called when bundles are stopped. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bundle tracker id or &lt; 0 if unsuccessful. </dd></dl>

</div>
</div>
<a class="anchor" id="aa603acb136351b4135ce6a8c0b1fda71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long celix_bundleContext_trackBundlesWithOptions </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="celix__bundle__context_8h.html#ae6fb701de56577ab43263b5619604e86">celix_bundle_tracking_options_t</a> *&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tracks bundles using the provided bundle tracker options. The tracker options are only using during this call and can safely be freed/reused after this call returns. (i.e. can be on the stack)</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The bundle context. </td></tr>
    <tr><td class="paramname">opts</td><td>The pointer to the bundle tracker options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The bundle tracker id (&gt;=0) or &lt; 0 if unsuccessful. </dd></dl>

</div>
</div>
<a class="anchor" id="a612409acf5453dbc370d93b784153d51"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long celix_bundleContext_trackService </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>serviceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *handle, void *svc)&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>track the highest ranking service with the provided serviceName. The highest ranking services will used for the callback. If a new and higher ranking services the callback with be called again with the new service. If a service is removed a the callback with be called with next highest ranking service or NULL as service.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The bundle context. </td></tr>
    <tr><td class="paramname">serviceName</td><td>The required service name to track </td></tr>
    <tr><td class="paramname">callbackHandle</td><td>The data pointer, which will be used in the callbacks </td></tr>
    <tr><td class="paramname">set</td><td>is a required callback, which will be called when a new highest ranking service is set. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tracker id (&gt;=0) or &lt; 0 if unsuccessful. </dd></dl>

</div>
</div>
<a class="anchor" id="a43e3bfd38ef956ffe861065e698a72e4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long celix_bundleContext_trackServices </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>serviceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *handle, void *svc)&#160;</td>
          <td class="paramname"><em>add</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *handle, void *svc)&#160;</td>
          <td class="paramname"><em>remove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>track services with the provided serviceName.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The bundle context. </td></tr>
    <tr><td class="paramname">serviceName</td><td>The required service name to track </td></tr>
    <tr><td class="paramname">callbackHandle</td><td>The data pointer, which will be used in the callbacks </td></tr>
    <tr><td class="paramname">add</td><td>is a required callback, which will be called when a service is added and initially for the existing service. </td></tr>
    <tr><td class="paramname">remove</td><td>is a required callback, which will be called when a service is removed </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tracker id (&gt;=0) or &lt; 0 if unsuccessful. </dd></dl>

</div>
</div>
<a class="anchor" id="a27980e1631d4575cc45c6c6ba38c6f71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long celix_bundleContext_trackServicesWithOptions </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="celix__bundle__context_8h.html#a4e53ca7fd5a9c2b792ff0a8e048236d2">celix_service_tracking_options_t</a> *&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Tracks services using the provided tracker options. The tracker options are only using during this call and can safely be freed/reused after this call returns.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The bundle context. </td></tr>
    <tr><td class="paramname">opts</td><td>The pointer to the tracker options. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the tracker id (&gt;=0) or &lt; 0 if unsuccessful. </dd></dl>

</div>
</div>
<a class="anchor" id="a80f61dd38b9da8447cd4f931779eaf16"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long celix_bundleContext_trackServiceTrackers </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>serviceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *handle, const <a class="el" href="celix__bundle__context_8h.html#a69f5283bcb563038d1a8e35e2a2b028b">celix_service_tracker_info_t</a> *info)&#160;</td>
          <td class="paramname"><em>trackerAdd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *handle, const <a class="el" href="celix__bundle__context_8h.html#a69f5283bcb563038d1a8e35e2a2b028b">celix_service_tracker_info_t</a> *info)&#160;</td>
          <td class="paramname"><em>trackerRemove</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Track the service tracker targeting the provided service name. This can be used to track if there is an interest in a certain service and ad-hoc act on that interest.</p>
<p>Note that the celix_service_tracker_info_t pointer in the trackerAdd/trackerRemove callbacks are only valid during the callback.</p>
<p>This tracker can be stopped with the celix_bundleContext_stopTracker function.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The bundle context </td></tr>
    <tr><td class="paramname">serviceName</td><td>The target service name for the service tracker to track. </td></tr>
    <tr><td class="paramname">callbackHandle</td><td>The callback handle which will be provided as handle in the trackerAdd and trackerRemove callback. </td></tr>
    <tr><td class="paramname">trackerAdd</td><td>Called when a service tracker is added, which tracks the provided service name. Will also be called for all existing service tracker when this tracker is started. </td></tr>
    <tr><td class="paramname">trackerRemove</td><td>Called when a service tracker is removed, which tracks the provided service name </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The tracker id or &lt;0 if something went wrong (will log an error). </dd></dl>

</div>
</div>
<a class="anchor" id="a098adf1e9f65deb166110008bd4314dd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool celix_bundleContext_uninstallBundle </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>bundleId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Uninstall the bundle with the provided bundle id. If needed the bundle will be stopped first. Will silently ignore bundle ids &lt; 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The bundle context </td></tr>
    <tr><td class="paramname">bundleId</td><td>The bundle id to uninstall. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>true if the bundle is correctly uninstalled. False if not. </dd></dl>

</div>
</div>
<a class="anchor" id="a1ebd82cb3d61aab769956d856293b9b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void celix_bundleContext_unregisterService </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>serviceId</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Unregister the service or service factory with service id. The service will only be unregistered if the bundle of the bundle context is the owner of the service.</p>
<p>Will log an error if service id is unknown. Will silently ignore services ids &lt; 0.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The bundle context </td></tr>
    <tr><td class="paramname">serviceId</td><td>The service id </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abb3cedf5ffa7a326cef2af64a1094635"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool celix_bundleContext_useBundle </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>bundleId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *handle, const celix_bundle_t *bundle)&#160;</td>
          <td class="paramname"><em>use</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the bundle with the provided bundle id if it is in the active (started) state The provided callback will be called if the bundle is found and in the active (started) state.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The bundle context. </td></tr>
    <tr><td class="paramname">bundleId</td><td>The bundle id. </td></tr>
    <tr><td class="paramname">callbackHandle</td><td>The data pointer, which will be used in the callbacks </td></tr>
    <tr><td class="paramname">use</td><td>The callback which will be called for the currently started bundles. The bundle pointers are only guaranteed to be valid during the callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns true if the bundle is found and the callback is called. </dd></dl>

</div>
</div>
<a class="anchor" id="a03a6d1c49c91c212ad7be115e1035840"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void celix_bundleContext_useBundles </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *handle, const celix_bundle_t *bundle)&#160;</td>
          <td class="paramname"><em>use</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the currently active (started) bundles. The provided callback will be called for all the currently started bundles (excluding the framework bundle).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The bundle context. </td></tr>
    <tr><td class="paramname">callbackHandle</td><td>The data pointer, which will be used in the callbacks </td></tr>
    <tr><td class="paramname">use</td><td>The callback which will be called for the currently started bundles. The bundle pointers are only guaranteed to be valid during the callback. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac36cdb8a06bb34f9371d7bb32953c69e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool celix_bundleContext_useService </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>serviceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *handle, void *svc)&#160;</td>
          <td class="paramname"><em>use</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the highest ranking service with the provided service name using the provided callback. The Celix framework will ensure that the targeted service cannot be removed during the callback.</p>
<p>The svc is should only be considered valid during the callback. If no service is found the callback will not be invoked.</p>
<p>This function will block till the callback is finished. As result it is possible to provide callback data from the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The bundle context </td></tr>
    <tr><td class="paramname">serviceName</td><td>the required service name. </td></tr>
    <tr><td class="paramname">callbackHandle</td><td>The data pointer, which will be used in the callbacks </td></tr>
    <tr><td class="paramname">use</td><td>The callback, which will be called when service is retrieved. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a service was found. </dd></dl>

</div>
</div>
<a class="anchor" id="a39270507a3766afbfcc9420c7270d262"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void celix_bundleContext_useServices </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>serviceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *handle, void *svc)&#160;</td>
          <td class="paramname"><em>use</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the services with the provided service name using the provided callback. The Celix framework will ensure that the targeted service cannot be removed during the callback.</p>
<p>The svc is should only be considered valid during the callback. If no service is found the callback will not be invoked.</p>
<p>This function will block till the callback is finished. As result it is possible to provide callback data from the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The bundle context </td></tr>
    <tr><td class="paramname">serviceName</td><td>the required service name. </td></tr>
    <tr><td class="paramname">callbackHandle</td><td>The data pointer, which will be used in the callbacks </td></tr>
    <tr><td class="paramname">use</td><td>The callback, which will be called for every service found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad1512520baedecad54a7bc307e0a6c7b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void celix_bundleContext_useServicesWithOptions </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="celix__bundle__context_8h.html#abc6f11edf20a71cbade3668e4bc66ed6">celix_service_use_options_t</a> *&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the services with the provided service filter options using the provided callback. The Celix framework will ensure that the targeted service cannot be removed during the callback.</p>
<p>The svc is should only be considered valid during the callback. If no service is found the callback will not be invoked.</p>
<p>This function will block till the callback is finished. As result it is possible to provide callback data from the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The bundle context. </td></tr>
    <tr><td class="paramname">opts</td><td>The required options. Note that the serviceName is required. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aec6e03faece0f8247de19d8c1527406d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool celix_bundleContext_useServiceWithId </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long&#160;</td>
          <td class="paramname"><em>serviceId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>serviceName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>callbackHandle</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(void *handle, void *svc)&#160;</td>
          <td class="paramname"><em>use</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the service with the provided service id using the provided callback. The Celix framework will ensure that the targeted service cannot be removed during the callback.</p>
<p>The svc is should only be considered valid during the callback. If no service is found the callback will not be invoked.</p>
<p>This function will block till the callback is finished. As result it is possible to provide callback data from the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The bundle context </td></tr>
    <tr><td class="paramname">serviceId</td><td>the service id. </td></tr>
    <tr><td class="paramname">serviceName</td><td>the service name of the service. Should match with the registered service name of the provided service id (sanity check) </td></tr>
    <tr><td class="paramname">callbackHandle</td><td>The data pointer, which will be used in the callbacks </td></tr>
    <tr><td class="paramname">use</td><td>The callback, which will be called when service is retrieved. </td></tr>
    <tr><td class="paramname">bool</td><td>returns true if a service was found. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a1e8a78de5f799d303231385b51085055"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool celix_bundleContext_useServiceWithOptions </td>
          <td>(</td>
          <td class="paramtype">celix_bundle_context_t *&#160;</td>
          <td class="paramname"><em>ctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="celix__bundle__context_8h.html#abc6f11edf20a71cbade3668e4bc66ed6">celix_service_use_options_t</a> *&#160;</td>
          <td class="paramname"><em>opts</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Use the services with the provided service filter options using the provided callback. The Celix framework will ensure that the targeted service cannot be removed during the callback.</p>
<p>The svc is should only be considered valid during the callback. If no service is found the callback will not be invoked.</p>
<p>This function will block till the callback is finished. As result it is possible to provide callback data from the stack.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctx</td><td>The bundle context. </td></tr>
    <tr><td class="paramname">opts</td><td>The required options. Note that the serviceName is required. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>True if a service was found. </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
